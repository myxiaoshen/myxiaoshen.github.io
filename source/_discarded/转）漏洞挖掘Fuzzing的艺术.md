title: （转）漏洞挖掘Fuzzing的艺术与总结
author: Believe firmly
date: 2020-01-02 10:05:54
tags:
---
<div class="articlecontent"><div class="title clearfix"><h2>                                    谈高效漏洞挖掘之Fuzzing的艺术</h2><!--more--><div class="property"><span class="name"><a href="https://www.freebuf.com/author/Qclover" title="由 Qclover 发布" rel="author">Qclover</a></span><div id="toc_container" class="toc_white no_bullets"><blockquote><p><span style="color: rgb(91, 91, 91); font-size: 12px;"></span><a href="https://gh0st.cn/archives/2019-11-11/1">https://gh0st.cn/archives/2019-11-11/1</a><span style="color: rgb(91, 91, 91); font-size: 12px;"></span></p>
</blockquote><p class="toc_title">文章目录</p><ul class="toc_list"><li><a href="#i">一、登陆</a></li><li><a href="#i-2">二、逻辑漏洞</a><ul><li><a href="#21fuzz">2.1敏感信息泄露（接口参数fuzz+驼峰命名法）</a></li><li><a href="#22-1">2.2逻辑漏洞-越权1（参数值替换）</a></li><li><a href="#23-2">2.3逻辑漏洞-越权2（参数值枚举）</a></li><li><a href="#24-idoridor">2.4逻辑漏洞-IDOR（IDOR-不安全的直接对象引用）</a></li><li><a href="#25">2.5回显伪造-本地验证</a></li><li><a href="#26-gtfuzz-gt">2.6逻辑漏洞-&gt;【参数fuzz】-&gt;未授权</a></li><li><a href="#27-gtjsfuzz">2.7逻辑漏洞-越权-&gt;js信息接口fuzz</a></li></ul></li><li><a href="#xxe-fuzzing">三、XXE-Fuzzing</a></li><li><a href="#csrf-fuzzing">四、CSRF-Fuzzing</a><ul><li><ul><li><a href="#csrf">读取型CSRF</a></li></ul></li></ul></li><li><a href="#ssrf-or-urlext-fuzzing">五、SSRF-or-URL跳转漏洞ext-Fuzzing</a></li><li><a href="#fuzz">六、黑盒测试中的漏洞利用链FUZZ</a></li><li><a href="#i-3">参考资料</a></li></ul></div><p><b style="color: rgb(0, 176, 80);">之前写过一个比较入门的<a href="https://xz.aliyun.com/t/5398">漏洞挖掘浅谈</a>，而之后的漏洞挖掘和工作中的产品测试过程中除了白盒代码审计之外比较偏向黑盒测试/漏洞挖掘，那么我觉得漏洞挖掘/黑盒测试过程中的遇到过的一些fuzz技术思想有必要借用我遇到过的实战中的例子来归纳总结下，通过实例对fuzz的思想进行展开。</b></p><h2><span id="i">一、登陆</span></h2><p><strong>1）验证码</strong></p><p>图片验证码1 -&gt;拒绝服务攻击</p><p>-》Fuzz存在潜藏参数，可控验证码生成大小： 如存在验证码生成包中存在height、width、length等参数且能够被我们控制那么就可能进行拒绝服务攻击<a href="https://image.3001.net/images/20191125/1574691522_5ddbe2c2f2ad0.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691522_5ddbe2c2f2ad0.png!small" src="https://image.3001.net/images/20191125/1574691522_5ddbe2c2f2ad0.png!small" alt="code" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691522_5ddbe2c2f2ad0.png!small" alt="code" width="690" height="141"></p></noscript><p><a href="https://image.3001.net/images/20191125/1574691641_5ddbe33960399.jpg" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691641_5ddbe33960399.jpg!small" src="https://image.3001.net/images/20191125/1574691641_5ddbe33960399.jpg!small" alt="code" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691641_5ddbe33960399.jpg!small" alt="code" width="690" height="390"></p></noscript><p>图片验证码2-&gt;删除验证码参数bypass验证</p><p>手机验证码1-&gt;爆破</p><p>手机验证码2-&gt;短信轰炸</p><p><strong>2）用户名枚举</strong></p><p>若测试中回显信息出现用户名不存在、或者回显code与正确的code不同时则可能存在用户名枚举</p><p><a href="https://image.3001.net/images/20191125/1574691833_5ddbe3f9966a6.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img alt="1.png" data-original="https://image.3001.net/images/20191125/1574691833_5ddbe3f9966a6.png!small" src="https://image.3001.net/images/20191125/1574691833_5ddbe3f9966a6.png!small" width="609" style="display: block;"></a></p><noscript><img alt="1.png" src="https://image.3001.net/images/20191125/1574691833_5ddbe3f9966a6.png!small" width="609" height="503"></p></noscript><p><strong>3）弱口令</strong></p><h2><span id="i-2"><strong>二、逻辑漏洞</strong></span></h2><h3><span id="21fuzz">2.1敏感信息泄露（接口参数fuzz+驼峰命名法）</span></h3><p>原本是一个如下一个根据个人信息显示订单的请求数据包</p><pre><code class="hljs dts">POST<span class="hljs-meta-keyword">/sale/</span>appOrder/orderInfo HTTP/<span class="hljs-number">1.1</span><span class="hljs-symbol">Host:</span> xxx.com<span class="hljs-symbol">Origin:</span> http:<span class="hljs-comment">//xxx.com</span><span class="hljs-symbol">Cookie:</span>****...orderId=<span class="hljs-number">1234</span></code></pre><p>返回的一个正常的个人订单信息。然而我将post的内容删除后，请求接口上继续Fuzz参数并配合驼峰命名规则</p><pre><code class="hljs dts">POST<span class="hljs-meta-keyword">/sale/</span>appOrder/+paramFuzzing HTTP/<span class="hljs-number">1.1</span><span class="hljs-symbol">Host:</span> xxx.com<span class="hljs-symbol">Origin:</span> http:<span class="hljs-comment">//xxx.com</span><span class="hljs-symbol">Cookie:</span>****...</code></pre><p>最终得到大量订单信息的泄露</p><p><a href="https://image.3001.net/images/20191125/1574691868_5ddbe41cbd550.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691868_5ddbe41cbd550.png!small" src="https://image.3001.net/images/20191125/1574691868_5ddbe41cbd550.png!small" alt="2" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691868_5ddbe41cbd550.png!small" alt="2" width="690" height="336"></p></noscript><h3><span id="22-1">2.2逻辑漏洞-越权1（参数值替换）</span></h3><p>将相关的信息字段内容替换为测试账号B的信息（例如：login=A-&gt; login=B</p><p>、userid=A-&gt;userid=B）</p><p><a href="https://image.3001.net/images/20191125/1574691897_5ddbe4393dbcd.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691897_5ddbe4393dbcd.png!small" src="https://image.3001.net/images/20191125/1574691897_5ddbe4393dbcd.png!small" alt="4" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691897_5ddbe4393dbcd.png!small" alt="4" width="690" height="298"></p></noscript><h3><span id="23-2">2.3逻辑漏洞-越权2（参数值枚举）</span></h3><p>对于以上情况在不知道账户2的id或不想另注册测试账户时用到另一种暴力而简便方法，可能大家都知道intruder.</p><p><a href="https://image.3001.net/images/20191125/1574691961_5ddbe479b0653.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691961_5ddbe479b0653.png!small" src="https://image.3001.net/images/20191125/1574691961_5ddbe479b0653.png!small" alt="5" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691961_5ddbe479b0653.png!small" alt="5" width="690" height="334"></p></noscript><p><a href="https://image.3001.net/images/20191125/1574691984_5ddbe4907b9ef.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574691984_5ddbe4907b9ef.png!small" src="https://image.3001.net/images/20191125/1574691984_5ddbe4907b9ef.png!small" alt="6" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574691984_5ddbe4907b9ef.png!small" alt="6" width="690" height="669"></p></noscript><h3><span id="24-idoridor">2.4逻辑漏洞-IDOR（IDOR-不安全的直接对象引用）</span></h3><p>IDOR或许和越权有点像，在测试越权修改user_id时也许经常会看到401未认证或用户未授权，大多少人会和我之前的我一样结束这样一个越权测试，认为目标系统不存在越权漏洞。但在正是了解和接触IDOR之后测试面才会不断发散扩展。IDOR漏洞不仅限于参数数值更改，它还包括<strong>参数数值删除</strong>，以及其他与个人信息相关的字段<strong>替换</strong>以及<strong>HTTP污染</strong>等。</p><p>》举例</p><p>假如请求中存在以下参数</p><pre><code class="hljs cpp">{<span class="hljs-string">"userid"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">""</span>meail<span class="hljs-string">":"</span><span class="hljs-string">","</span>content<span class="hljs-string">":"</span><span class="hljs-string">","</span>anmousid<span class="hljs-string">":"</span><span class="hljs-string">",user_hash"</span>:<span class="hljs-string">""</span>,}</code></pre><p>1）替换请求中的userid</p><p>经常会出现</p><p>A</p><pre><code class="hljs">HTTP/1.1 404....error</code></pre><p>B</p><pre><code class="hljs">HTTP/1.1 403....error</code></pre><p>C</p><pre><code class="hljs">HTTP/1.1 401...未认证</code></pre><p>2）删除请求中对应的token/user_hash</p><p>保留userid,将与其对应的token/user_hash参数值删除 ,原例A-&gt;B</p><p>3)删除userid及对应user_hash</p><p>返回结果如B</p><p>但是最后当将userid、user_hash、anmousid都删除只保留email和content时却认证成功返回了数据。</p><p>对于C中情况测试还存在一个IDOR的Bypass，<strong>HTTP参数污染。</strong></p><p><a href="https://image.3001.net/images/20191125/1574692019_5ddbe4b303495.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692019_5ddbe4b303495.png!small" src="https://image.3001.net/images/20191125/1574692019_5ddbe4b303495.png!small" alt="8" width="457" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692019_5ddbe4b303495.png!small" alt="8" width="457" height="258"></p></noscript><p>如图一个资产可能存在多种服务或程序，他们的请求或处理或参数解析方面可能存在不同，即平常所说的解析差异。那么我们可以发送一个数值参数来造成WEB应用后端的解析混乱，当我们发送多个数值参数又会如何？那么我们可以发送具备不同数值的同名参数去混乱Web后端解析机制，通过这种攻击来（HTTP参数污染-HPP）实现我们的IDOR Bypass。由于测试中未遇到过此bypass漏洞，这里借用大佬的一张图作为例子</p><p><a href="https://image.3001.net/images/20191125/1574692035_5ddbe4c312b7b.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692035_5ddbe4c312b7b.png!small" src="https://image.3001.net/images/20191125/1574692035_5ddbe4c312b7b.png!small" alt="7" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692035_5ddbe4c312b7b.png!small" alt="7" width="690" height="197"></p></noscript><p>具体可参考<a href="https://www.freebuf.com/vuls/216774.html">https://www.freebuf.com/vuls/216774.html</a></p><h3><span id="25"><strong>2.5回显伪造-本地验证</strong></span></h3><p>当回显error时替换换为正确的回显内容，绕过验证</p><p>1）获取验证码后任意输入一个验证码。<a href="https://image.3001.net/images/20191125/1574692185_5ddbe559e9bfc.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692185_5ddbe559e9bfc.png!small" src="https://image.3001.net/images/20191125/1574692185_5ddbe559e9bfc.png!small" alt="img" width="662" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692185_5ddbe559e9bfc.png!small" alt="img" width="662" height="330"></p></noscript><p>2）抓包放行，得到的返回包如下<a href="https://image.3001.net/images/20191125/1574692406_5ddbe6362a14c.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692406_5ddbe6362a14c.png!small" src="https://image.3001.net/images/20191125/1574692406_5ddbe6362a14c.png!small" alt="img" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692406_5ddbe6362a14c.png!small" alt="img" width="690" height="210"></p></noscript><p>3）抓包改返回包修改为正确的返回包覆盖错误的返回包，如下</p><p>{“code”:1,”data”:”目标用户手机号”,”msg”:”绑定成功Ÿ”}<a href="https://image.3001.net/images/20191125/1574692414_5ddbe63e681eb.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692414_5ddbe63e681eb.png!small" src="https://image.3001.net/images/20191125/1574692414_5ddbe63e681eb.png!small" alt="img" width="593" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692414_5ddbe63e681eb.png!small" alt="img" width="593" height="226"></p></noscript><p>4）放行，修改成功<a href="https://image.3001.net/images/20191125/1574692428_5ddbe64caa6f1.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692428_5ddbe64caa6f1.png!small" src="https://image.3001.net/images/20191125/1574692428_5ddbe64caa6f1.png!small" alt="img" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692428_5ddbe64caa6f1.png!small" alt="img" width="690" height="301"></p></noscript><p>漏洞本质：服务端没有对用户的上一步操作进行验证</p><h3><span id="26-gtfuzz-gt">2.6逻辑漏洞-&gt;【参数fuzz】-&gt;未授权</span></h3><p>得到一个某后台管理系统的URL:<a href="https://xxx/?m=index%EF%BC%8C%E8%AF%A5URL%E8%AE%BF%E9%97%AE%E8%A7%A3%E6%9E%90%E8%BF%87%E6%9D%A5%E7%9A%84%E6%98%AF%E4%B8%BB%E2%BB%9A%E4%BF%A1%E6%81%AF%E3%80%82">https://xxx/?m=index，该URL访问解析过来的是主⻚信息。</a></p><p>尝试对请求参数m的值进行Fuzz，利用参数字典进行Fuzz，方法和前面的敏感信息泄露（接口参数fuzz方法）类似。</p><h3><span id="27-gtjsfuzz"><strong>2.7逻辑漏洞-越权-&gt;js信息接口fuzz</strong></span></h3><p>当遇到一个只有登陆框的网站时，我们能得到的信息少之又少时，查看源码fuzz网站的js信息能得到意想不到的收获，如隐藏的域名和接口。</p><p>1）敏感接口</p><p><a href="https://image.3001.net/images/20191125/1574692751_5ddbe78f140d9.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692751_5ddbe78f140d9.png!small" src="https://image.3001.net/images/20191125/1574692751_5ddbe78f140d9.png!small" alt="9" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692751_5ddbe78f140d9.png!small" alt="9" width="690" height="438"></p></noscript><p>一般可能出现越权或未授权漏洞</p><p>2）隐藏域名</p><p>我在挖掘末src某网站xxx.cn时，一番努力之后发现并无所获，而这时通过查看源码，意外的发现一个特殊的域名<strong>bbs.abc.com</strong>,我在其后面加上admin之后意外的跳转到了<a href="https://bbs.abc.com/admin/#/home/dashboard">https://bbs.abc.com/admin/#/home/dashboard</a> 后台，该bbs.abc.com为xxx.cn开发人员的一个测试网站存在着大量后台接口越权。</p><p><a href="https://image.3001.net/images/20191125/1574692770_5ddbe7a2e9807.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692770_5ddbe7a2e9807.png!small" src="https://image.3001.net/images/20191125/1574692770_5ddbe7a2e9807.png!small" alt="10" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692770_5ddbe7a2e9807.png!small" alt="10" width="690" height="272"></p></noscript><p><a href="https://image.3001.net/images/20191125/1574692909_5ddbe82dac930.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692909_5ddbe82dac930.png!small" src="https://image.3001.net/images/20191125/1574692909_5ddbe82dac930.png!small" alt="11" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692909_5ddbe82dac930.png!small" alt="11" width="690" height="338"></p></noscript><h2><span id="xxe-fuzzing"><span style="color: rgb(51, 51, 51);">三、XXE-Fuzzing</span></span></h2><p>对于xxe的测试，是当一个数据包的中出现</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version='1.0' encoding='utf-8' ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE ......?&gt;</span></code></pre><p>即对XML文件进行解析的场景中，都有可能出现XXE注入，如提交时，还有在上传中文件类型指定了excel、or word那么都可以进行Fuzz测试。关于XXE详细的利用可参考我之前的<a href="http://qclover.cn/2019/11/14/PHP%E4%B8%8EJ**A%E4%B9%8BXXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%A1%E8%AE%A1.html"><strong>PHP与J**A之XXE漏洞详解与审计</strong></a>记录了白盒审计及黑盒测试利用详细的过程。</p><h2><span id="csrf-fuzzing"><strong style="color: rgb(51, 51, 51);">四、CSRF-Fuzzing</strong></span></h2><h4><span id="csrf">读取型CSRF</span></h4><p>1)jsonp 劫持</p><p><a href="https://image.3001.net/images/20191125/1574692966_5ddbe866465c5.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574692966_5ddbe866465c5.png!small" src="https://image.3001.net/images/20191125/1574692966_5ddbe866465c5.png!small" alt="1573991576207" width="648" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574692966_5ddbe866465c5.png!small" alt="1573991576207" width="648" height="182"></p></noscript><p>POC</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-title">jsonp</span>(<span class="hljs-params">data</span>)</span>{alert(<span class="hljs-built_in">JSON</span>.stringify(data));}</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span><span class="hljs-attr">src</span>=<span class="hljs-string">"http://vul.com/user/center?callback=jsonp"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>2)cors -&gt;crossdomain.xml-&gt;flash</p><p>若测试某资产时发现存在crossdomain.xml,并且内容如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cross-domain-policy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">allow-access-from</span><span class="hljs-attr">domain</span>=<span class="hljs-string">"*"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cross-domain-policy</span>&gt;</span></code></pre><p>则存在swf的跨域的读取CSRF</p><p><a href="https://raw.githubusercontent.com/Qclover/CSRF/master/BypassX-Request-With/2.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://raw.githubusercontent.com/Qclover/CSRF/master/BypassX-Request-With/2.png" src="https://raw.githubusercontent.com/Qclover/CSRF/master/BypassX-Request-With/2.png" alt="img" style="display: block;"></a></p><noscript><img src="https://raw.githubusercontent.com/Qclover/CSRF/master/BypassX-Request-With/2.png" alt="img"></p></noscript><p>详细利用可参考我之前的利用方式的<a href="https://github.com/Qclover/CSRF">记录</a>里面包含了poc构造工具。另外关于CSRF的利用及其防护也可参考之前的<a href="https://xz.aliyun.com/t/6414">一篇文章</a>。</p><p>3)CORS跨域资源请求</p><p>在请求的时候加上了请求头<code>Origin:<a href="http://xxx.com">http://xxx.com</a></code>，而对应的响应包中出现了`Access-Control-Allow-Origin:<a href="">http://vul.com这个响应头其实就是访问控制允许，在这里是允许http://vul.cm的请求的，所以目标http://vul.com是可以被跨域读取该网址的内容</a></p><h2><span id="ssrf-or-urlext-fuzzing"><strong style="color: rgb(51, 51, 51);">五、SSRF-or-URL跳转漏洞ext-Fuzzing</strong></span></h2><p>资产测试时可能存在这样的URL:</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/vul.php?url=http://www.xxc.com/xxx.jpg</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//xxx.com/notice/?info=xxx&amp;gourl=</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//xxx.com/api/?uri=xxx&amp;redict=</span></code></pre><p>对于如上这样的GET型的链接Fuzz的点有什么呢？SSRF、url跳转，结束了吗?ext扩展发散一下其实还有，只是平常利用的比较少或比较少想到在一次机缘巧合刚好想到也刚好遇上了，继续fuzzing下，其实还可以考虑<strong>CRLF</strong>，url_redict+CRLF、CRLF+XSS。</p><p><strong>对于SSRF</strong></p><p>测试</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/vul.php?url=http://127.0.0.1:port</span></code></pre><p>根据回显内容和状态即可确定漏洞是否存在。</p><p>协议利用</p><pre><code class="hljs dts">gopher<span class="hljs-symbol">http:</span><span class="hljs-comment">//127.0.0.1/ssrf.php?url=gopher://127.0.0.1:2333/_test</span>dict<span class="hljs-symbol">http:</span><span class="hljs-comment">//4o4notfound.org/ssrf.php?url=dict://127.0.0.1:port/info</span>file<span class="hljs-symbol">http:</span><span class="hljs-comment">//4o4notfound.org/ssrf.php?url=file:///etc/passwd</span>http<span class="hljs-symbol">http:</span><span class="hljs-comment">//4o4notfound.org/ssrf.php?url=http://xxx.com/302.php</span></code></pre><p>协议限制为http下向服务端提交302.php</p><pre><code class="hljs xml"><span class="php"><span class="hljs-meta">&lt;?php</span>header(<span class="hljs-string">"Location: file:///etc/passwd"</span>);<span class="hljs-meta">?&gt;</span></span></code></pre><p>辅助脚本302.php—-bypass http协议限制</p><pre><code class="hljs perl">&lt;?php$ip = $_GET[<span class="hljs-string">'ip'</span>];$port = $_GET[<span class="hljs-string">'port'</span>];$scheme = $_GET[<span class="hljs-string">'s'</span>];$data = $_GET[<span class="hljs-string">'data'</span>];header(<span class="hljs-string">"Location: $scheme://$ip:$port/$data"</span>); ?&gt;</code></pre><p>测试完SSRF后发现没有该漏洞~</p><p><a href="https://image.3001.net/images/20191125/1574693054_5ddbe8bea5215.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574693054_5ddbe8bea5215.png!small" src="https://image.3001.net/images/20191125/1574693054_5ddbe8bea5215.png!small" alt="1574431569568" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574693054_5ddbe8bea5215.png!small" alt="1574431569568" width="690" height="193"></p></noscript><p><a href="https://image.3001.net/images/20191125/1574693106_5ddbe8f22dc45.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574693106_5ddbe8f22dc45.png!small" src="https://image.3001.net/images/20191125/1574693106_5ddbe8f22dc45.png!small" alt="1574431518002" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574693106_5ddbe8f22dc45.png!small" alt="1574431518002" width="690" height="268"></p></noscript><p>转入URL跳转测试</p><p><a href="https://image.3001.net/images/20191125/1574693125_5ddbe9059edad.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574693125_5ddbe9059edad.png!small" src="https://image.3001.net/images/20191125/1574693125_5ddbe9059edad.png!small" alt="1574431730099" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574693125_5ddbe9059edad.png!small" alt="1574431730099" width="690" height="202"></p></noscript><p><a href="https://image.3001.net/images/20191125/1574693143_5ddbe917910e7.png" class="highslide-image" onclick="return hs.expand(this);" target="_blank"><img data-original="https://image.3001.net/images/20191125/1574693143_5ddbe917910e7.png!small" src="https://image.3001.net/images/20191125/1574693143_5ddbe917910e7.png!small" alt="1574431772440" width="690" style="display: block;"></a></p><noscript><img src="https://image.3001.net/images/20191125/1574693143_5ddbe917910e7.png!small" alt="1574431772440" width="690" height="194"></p></noscript><p>结束了么？没有，那么是否还存在其他利用方式呢？</p><p>往下测试之前，我们先来看看URL跳转以及<strong>CRLF</strong>的原理.</p><p><strong>插叙</strong></p><p>CRLF 指的是<strong>回车符</strong>(CR，ASCII 13，\r，%0d) 和<strong>换行符</strong>(LF，ASCII 10，\n，%0a)。</p><p>正常的一个请求</p><pre><code class="hljs dts">GET api<span class="hljs-meta-keyword">/xxxx/</span>?url=http:<span class="hljs-comment">//www.xxc.com</span><span class="hljs-symbol">Host:</span>qclover.cnUser-Agent:xxxxx...<span class="hljs-symbol">Referer:</span>http:qclover.cn<span class="hljs-symbol">Cookie:</span>xxxxxxxxxx...</code></pre><p>抓包，在请求行的url参数中加入特殊构造的CRLF字符 如下</p><pre><code class="hljs dts">GET api<span class="hljs-meta-keyword">/xxxx/</span>?url=http:<span class="hljs-comment">//www.xxc.com%0d%0aSet-Cookie:vuale=crlf HTTP/1.1</span><span class="hljs-symbol">Host:</span>qclover.cnUser-Agent:xxxxx...<span class="hljs-symbol">Referer:</span>http:qclover.cn<span class="hljs-symbol">Cookie:</span>xxxxxxxxxx...</code></pre><p>输出</p><pre><code class="hljs sql">HTTP/1.1 302 Found...Location:http://www.xxc.com<span class="hljs-keyword">Set</span>-Cookie:vuale=crlf<span class="hljs-keyword">Content</span>-<span class="hljs-keyword">Length</span>:<span class="hljs-number">0</span><span class="hljs-keyword">Content</span>-<span class="hljs-keyword">Type</span>:<span class="hljs-built_in">text</span>/html</code></pre><p>这样一个CRLF对应的服务端的代码可能是这样子的</p><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">"url"</span>])&amp;&amp;($_cookie[<span class="hljs-string">"security_level"</span>]!=<span class="hljs-string">"1"</span>&amp;&amp;$_COOKIE[<span class="hljs-string">"security_level"</span>]!=<span class="hljs-string">"2"</span>)){    header(<span class="hljs-string">"Location:"</span>.GET[<span class="hljs-string">"url"</span>]);<span class="hljs-keyword">exit</span>;}</code></pre><p>代码的意思是当条件满足时，将请求包中的url参数值拼接到Location字符串中，并设置成响应头发送给客户端。</p><p>假设存在CRLF漏洞，响应包此时应该 会出现如下情况</p><pre><code class="hljs perl">HTTP/<span class="hljs-number">1.1</span><span class="hljs-number">302</span> Found...Location:http:<span class="hljs-regexp">//www</span>.xxc.com%0d%0aSet-Cookie:vuale=crlfContent-Length:<span class="hljs-number">0</span>Content-Type:text/html</code></pre><p>最终构造的Set-Cookie字符 会出现在HTTP头部的Cookie中且vuale=crlf会被设置成Cookie携带在Cookie中。 最终的数据包会如下：</p><pre><code class="hljs dts">GET api<span class="hljs-meta-keyword">/xxxx/</span>?url=http:<span class="hljs-comment">//www.xxc.com</span><span class="hljs-symbol">Host:</span>qclover.cnUser-Agent:xxxxx...<span class="hljs-symbol">Referer:</span>http:qclover.cn<span class="hljs-symbol">Cookie:</span>xxxxxxxxxx;vuale=crlf...</code></pre><p>了解CRLF的服务端的代码原理后，可以知道本质还是在代码中的Location,这与url（302）跳转类似，因此在存在url跳转的情况下还可以尝试Fuzz,转为url跳转-&gt;CRLF-&gt;CRLF+XSS的利用</p><p>CRLF+XSS,payload可以更改为</p><pre><code class="hljs perl">GET /xxxx/redirect=http:<span class="hljs-regexp">//www</span>.xxc.com%E5%98%8A%E5%98%8Dcontent-type:text/html%E5%98%8A%E5%98%8Dlocation:%E5%98%8A%E5%98%8D%E5%98%8A%E5%98%8D%E5%98%BCsvg/onload=alert%28innerHTML%28%29%E5%98%BE...</code></pre><p>会变成<code>-&gt;</code></p><pre><code class="hljs dts">GET<span class="hljs-meta-keyword">/xxxx/</span>redirect（CRLF）<span class="hljs-symbol">Host:</span>qclover.cncontent-type:text/html（CRLF）<span class="hljs-symbol">location:</span><span class="hljs-params">&lt;svg/onload=alert(innerHTML)&gt;</span></code></pre><p>若同时存在url跳转，payload可以变换一下,CRLF+XSS</p><pre><code class="hljs perl">GET api/xxxx/?url=http:<span class="hljs-regexp">//www</span>.xxc.com%0d%0aSet-Cookie:%BCsvg/onload=alert%28innerHTML%28%29%E5%98%BE HTTP/<span class="hljs-number">1.1</span>Host:qclover.cnUser-Agent:xxxxx...Referer:http:qclover.cnCookie:xxxxxxxxxx...</code></pre><p>那么<code>&lt;svg/onload=alert</code>1<code>&gt;</code>将会出现在cookie中。</p><h2><span id="fuzz"><span style="color: rgb(51, 51, 51);">六、黑盒测试中的漏洞利用链FUZZ</span></span></h2><p>最后简单说下黑盒测试中的漏洞利用链的Fuzz思路</p><p>在白盒代码审计中存在者多种的漏洞利用POP链如TP5-6的POP链曾被大多数人所发掘分析。而在黑盒测试审计中其实也存在可以利用漏洞链的思想。如对于功能及其组件的测试、就单纯的代码审计的情况下比较难发现其漏洞，一个压缩包上传代码中严格限制了其文件类型但会回显其上传的路径、而 在另外一处备份恢复时首先会默认对其文件进行解压，若抓包中解压的路径可控，将两者组合利用就可进行木马上传和RCE。在fuzz中找各功能组件之间的关联性。</p><p>在漏洞挖掘中，Fuzz中每一个漏洞都可能存在多样的利用方式，需要我们对每一个参数和漏洞点保持着善于发现和挖掘的思想或许会存在意外的收获，不断的渐渐前行~</p>


